---
translatedFrom: de
translatedWarning: Если вы хотите отредактировать этот документ, удалите поле «translationFrom», в противном случае этот документ будет снова автоматически переведен
editLink: https://github.com/ioBroker/ioBroker.docs/edit/master/docs/ru/lib/performance/Performancemonitoring-mit-Systemdatenpunkten.md
title: мониторинг производительности
hash: 6XZuyxG/P1K8Kb5EzN4iYtT7LNazGydyeGlH+NRvTxE=
---
# Мониторинг производительности
Отправной точкой для анализа производительности в ioBroker является список объектов в Admin. Там предоставляется системная информация о хосте или хостах (ioBroker поддерживает несколько хостов) и отдельные адаптеры. Доступ к этой информации осуществляется путем переключения списка объектов в экспертный режим:

[attachment = 6] 2018-07-14 19_08_43-objects - ioBroker.png [/ attachment]

[b] [u] Значения производительности хоста [/ u] [/ b]

Хост на языке ioBroker - это машина, на которой выполняется процесс контроллера ioBroker js. В среде с несколькими хостами для распределения нагрузки это также может быть несколько компьютеров. Даже соответствующая операционная система может отличаться. Хорошая задача, например, Стеки кластера Raspberry Pi справляются с аппаратным ограничением в 1 ГБ ОЗУ.

[attachment = 5] 2018-07-15 17_35_07- (2) .png [/ attachment] [color = # 808080](Jeff Geerling, youtube) [/ цвет]

Контроллер js ioBrokers координирует запуск и остановку адаптеров и выполняет дополнительные задачи по управлению системой в фоновом режиме. В Admin вы можете найти значения производительности для соответствующего хост-компьютера, а также для контроллера js под идентификатором [i] 'system.host. <Имя хост-компьютера>' [/ i].

Вот список отдельных показателей и их значение:

Показатель / тип данных / единица измерения

[список] [*] [b] жив [/ b] / logic / none [список] Указывает, активен ли контроллер jo ioBroker на хосте [/ list] [*] [b] diskFree [/ b] / Number / MiB [список] Свободное место на логическом диске, на котором установлен ioBroker, bi = двоичное число (1 МБ = 1 000 000 байт) <(1 МБ = 1 048 576 байт = 1 × 1024 × 1024 байт) [ / list] [*] [b] diskSize [/ b] / number / MiB [list] Общий том логического тома, на котором установлен ioBroker [/ list] [*] [b] diskWarning [/ b] / number /% [список] Здесь вы можете ввести процент. Предупреждение будет отображаться в администраторе, если свободное место на томе падает ниже этого значения (например, 20). Это особенно полезно, если адаптер истории активен. [Attachment = 4] 2018-07-15 18_44_47-intro - ioBroker.png [/ attachment] [/ list] [*] [b] freemem [/ b] / Number / MB [список] Общий объем доступной системной памяти ОЗУ хоста [/ list] [*] [b] inputCount [/ b] / number / / 15s [list] Количество изменений значений состояния. Событие ввода может, например, создания или установки значения [/ list] [*] [b] load [/ b] / number /% [list] Общая системная загрузка ЦП, усредненная по одной секунде каждый. Неудивительно, что в Windows это значение всегда равно 0 [/ list] [*] [b] mem [/ b] / number /% [list] использования памяти. Отношение свободной памяти к общей системной памяти [/ list] [*] [b] memHeapTotal [/ b] / number / MB [list] размер памяти кучи, зарезервированной контроллером js [/ list] [*] [b] memHeapUsed [ / b] / number / MB [список] Размер памяти кучи, используемой контроллером js [/ list] [*] [b] memRss [/ b] / number / MB [список] Резидентный набор, общий размер js -Контроллер в оперативной памяти [/ list] [*] [b] outputCount [/ b] / number / / 15s [list] Выходные события включают такие действия, как сравнение значений, запись значения в базу данных состояний, события из-за подписок или регистрация адаптера, например, Чтобы получить утверждения о .connected- или .alive-состояниях. Вот как происходят 8 событий, которые обычно находятся в выходном значении события в списке экземпляров. [/ List] [*] [b] uptime [/ b] / number / s [list] Время выполнения ioBroker на этом хосте с момента последнего Перезагрузка [/ list] [/ list]

Следующая диаграмма символически показывает, как куча, код и стек влияют на общее использование памяти [b] memRss [/ b] процесса nodejs:

[Приложение = 3] Unbenannt-5.png [/ присоединения]

Если главный js-контроллер сам предоставляет базу данных объектов и состояний для всей системы, эта мера является отличным способом определить разницу между 300 и 3000 объектами ioBroker в использовании памяти. Например, в моей системе Windows это значение составляет 3500 объектов, а 2700 состояний находятся в диапазоне от 75 до 128 МБ. Приветствую в nodejs интегрированную сборку мусора. С другой стороны, если я использую Redis в качестве базы данных состояний, использование памяти для контроллера js сократится до 50 МБ. (Теперь Redis нужно дополнительно 25 МБ = снова 75 МБ;))

Если число изменений состояния превышает производительность обработки зависимых потребителей событий (например, javascript с триггерами on:), в базах данных в памяти создается очередь. Это видно по потреблению памяти контроллера js. Как только загрузка системы снова падает, и потребителям событий дается достаточно времени для обработки ожидающих изменений значения, значение memRss возвращается к своему первоначальному значению:

[attachment = 2] 2018-07-15 20_26_08.png [/ attachment]

Как это часто бывает в этой среде, нельзя делать точные заявления о причине ошибок на основе фиксированных значений. Однако часто помогает наблюдение за безошибочной системой (= эталонные значения), а затем сравнение [b] той же системы [/ b] в условиях неисправности. Кроме того, очень полезно записывать ту или иную точку данных в гистограммах, например, Чтобы уловить тенденции и выбросы.

[b] [u] Значения производительности адаптеров [/ u] [/ b]

Каждый адаптер имеет свои собственные показатели производительности. Каждый из них хранится под идентификатором [i] 'system.adapter. <Имя_адаптера>. <Экземпляр>' [/ i] и несколько отличается от хоста.

Показатель / тип данных / единица измерения

[список] [*] [b] живой [/ b] / logic / none [список] Указывает, активен ли адаптер [/ list] [*] [b] подключен [/ b] / logic / none [ list] Указывает, ответил ли адаптер в течение последних 30 секунд. [/ list] [*] [b] inputCount [/ b] / number / / 15s [list] Количество изменений значений состояния. Событие ввода может, например, установки или установки значения [/ list] [*] [b] memHeapTotal [/ b] / number / MB [list] Размер памяти кучи, зарезервированной адаптером [/ list] [*] [b] memHeapUsed [ / b] / number / MB [список] Размер памяти кучи, используемой адаптером [/ list] [*] [b] memRss [/ b] / number / MB [список] Резидентный набор, общий размер адаптера в оперативной памяти использовать память [/ list] [*] [b] inputCount [/ b] / number / / 15s [list] Количество изменений значений состояния. Событие ввода может, например, от создания или установки значения [/ list] [*] [b] outputCount [/ b] / number / / 15s [список] Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события из-за подписок или регистрации адаптера, например, Чтобы получить утверждения о .connected- или .alive-состояниях. Так происходит 8 событий, которые обычно находятся в выходном значении события в списке экземпляров. [/ List] [*] [b] uptime [/ b] / number / s [list] Время выполнения адаптера с момента запуска адаптера [/ list] [/ список]

Например, если адаптер Javascript неожиданно переходит на несколько тысяч после изменения сценария 100 [b] событий inputCount [/ b], существует сильное предположение, что цикл запуска, i. Кольцевая ссылка встроена в его сценарий.

Также полезно рассмотреть [b] memRss [/ b], для Обнаружение утечек памяти через скрипты или в адаптерах. С подключенными [b] live [/ b] и [b] [/ b] вы можете визуально визуализировать состояние адаптера или подавить отображение неверных данных, если адаптер не может предоставить новые значения.

[u] [b] Перспектива и вопрос [/ b] [/ u]

Поскольку я просто показываю картину как взгляд в будущее (и в моей среде разработки):

[attachment = 1] 2018-07-14 19_08_43-o1.png [/ attachment]

Для адаптеров мне не хватает отображения загрузки процессора [b] cpu [/ b], вызванной отдельным адаптером. Ведь вы хотите узнать даже без ресурсоемкой установки дополнительного адаптера мониторинга, который является виновником в системе. После того, как nodejs является однопоточным, отображение здесь относится к ядру процессора. Больше 100% здесь нет.

Использование процессоров с несколькими ядрами не помогает, если адаптер показывает постоянно высокие значения. В этом случае целесообразны только более быстрый процессор (обычно более высокая тактовая частота), оптимизация программного кода или распределение нагрузки по нескольким адаптерам (если возможно).

Показатель [b] cputime [/ b] позволяет оценить сумму процессорного времени, использованного адаптером с момента запуска. Он предоставляет информацию о частоте или интенсивности (интенсивность ключевых слов), с которой программа запрашивает процессор. Эта сумма практически всегда ниже, чем все время работы адаптера [b] uptime [/ b], так как адаптер практически не посылает заказов процессору даже при интенсивном использовании.

Здесь вы можете хорошо видеть, как различные показатели и как выглядит реакция адаптера Javascript на внезапную волну требований во Flot:

[attachment = 0] 2018-07-15 21_22_11-Flot Edit.png [/ attachment]

Кстати, адаптер Javascript был уже настолько занят, что больше не мог сразу принимать все события. Это сформировало очередь событий.